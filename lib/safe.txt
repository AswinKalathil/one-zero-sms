import 'dart:math';

import 'package:one_zero/constants.dart';
import 'package:sqflite_common_ffi/sqflite_ffi.dart';
import 'package:mysql1/mysql1.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'dart:async';

// void main() async {
//   // Initialize SQLite
//   sqfliteFfiInit();
//   var db = await openDatabase('my_database.db');

//   // Sync database
//   await syncDatabase(db);
// }

Future<void> syncDatabase(Database db) async {
  // Push local changes to cloud
  await pushLocalChangesToCloud(db);

  // Fetch changes from cloud
  await fetchCloudChanges(db);

  // Store the current time as the last sync time
  await storeLastSyncTime(DateTime.now());
}

Future<void> storeLastSyncTime(DateTime time) async {
  final prefs = await SharedPreferences.getInstance();
  await prefs.setString('lastSyncTime', time.toIso8601String());
}

Future<DateTime> getLastSyncTime() async {
  final prefs = await SharedPreferences.getInstance();
  final lastSyncTimeString = prefs.getString('lastSyncTime');

  if (lastSyncTimeString != null) {
    return DateTime.parse(lastSyncTimeString);
  }

  // Return a default value if no sync time is stored
  return DateTime.now().subtract(Duration(days: 1)); // Default to 1 day ago
}

Future<void> pushLocalChangesToCloud(Database db) async {
  final List<String> tables = [
    'class_table',
    'stream_table',
    'subject_table',
    'stream_subjects_table',
    'student_table',
    'test_table',
    'test_score_table'
  ];

  // Create a MySQL connection
  final connection = await MySqlConnection.connect(dbSettingLocal);

  for (var table in tables) {
    // Push new and updated records
    final List<Map<String, dynamic>> pendingRecords =
        await db.rawQuery('SELECT * FROM $table WHERE sync_pending = 1');

    // Use a transaction for batch inserts/updates
    await connection.transaction((trans) async {
      for (var record in pendingRecords) {
        // Make a mutable copy of the record
        final mutableRecord = Map<String, dynamic>.from(record);
        mutableRecord.remove('sync_pending'); // Remove sync_pending
        mutableRecord.remove('last_modified');
        // Prepare the fields and values for the query, excluding null values
        final nonNullFields = mutableRecord.keys
            .where((key) => mutableRecord[key] != null)
            .join(', ');
        final nonNullPlaceholders = mutableRecord.keys
            .where((key) => mutableRecord[key] != null)
            .map((_) => '?')
            .join(', ');
        final updateFields = mutableRecord.keys
            .where((key) => mutableRecord[key] != null)
            .map((key) => '$key = VALUES($key)')
            .join(', ');

        // Only pass non-null values to the query
        final nonNullValues = mutableRecord.values
            .where((value) => value != null)
            .map((value) => value as Object)
            .toList();

        // Create the SQL query
        final query =
            'INSERT INTO $table ($nonNullFields) VALUES ($nonNullPlaceholders) '
            'ON DUPLICATE KEY UPDATE $updateFields';

        // Execute the query with non-null values
        await trans.query(query, nonNullValues);

        // Mark record as synced
        await db.rawUpdate(
            'UPDATE $table SET sync_pending = 0 WHERE id = ?', [record['id']]);
      }
    });

    // Handle deleted rows
    final List<Map<String, dynamic>> deletedRecords = await db.rawQuery(
        'SELECT * FROM deleted_records WHERE table_name = ?', [table]);

    for (var deletedRecord in deletedRecords) {
      await connection
          .query('DELETE FROM $table WHERE id = ?', [deletedRecord['id']]);

      // Remove from local deleted_records
      await db.rawDelete(
          'DELETE FROM deleted_records WHERE id = ?', [deletedRecord['id']]);
    }
  }

  await connection.close();
}

Future<void> fetchCloudChanges(Database db) async {
  try {
    // Get the last sync time
    final lastSyncTime = await getLastSyncTime();
    print('Last sync time: $lastSyncTime');

    // Connect to MySQL
    final MySqlConnection connection =
        await MySqlConnection.connect(dbSettingLocal);
    final List<String> tables = [
      'class_table',
      'stream_table',
      'subject_table',
      'stream_subjects_table',
      'student_table',
      'test_table',
      'test_score_table'
    ];

    for (var table in tables) {
      try {
        // Fetch only updated records since the last sync using last_modified
        final results = await connection.query(
          'SELECT * FROM $table WHERE last_modified > ?',
          [lastSyncTime.toUtc().toIso8601String()], // Ensure correct format
        );

        if (results.isEmpty) {
          // print('No new records found for $table');
        } else {
          print('Syncing $table: ${results.length} records');
        }

        for (var row in results) {
          try {
            // Check if record fields match local table structure
            Map<String, dynamic> record = {'id': row['id'], ...row.fields};

            // Remove sync_pending and last_modified fields
            record.remove('sync_pending'); // Remove sync_pending field
            record.remove(
                'last_modified'); // Remove if you don't need to manage this field locally

            // Check if the record exists locally
            final localRecord = await db
                .rawQuery('SELECT * FROM $table WHERE id = ?', [record['id']]);

            if (localRecord.isEmpty) {
              // Insert new record
              await db.insert(table, record);
            } else {
              // Update local record based on cloud data if applicable
              await db.update(
                table,
                record,
                where: 'id = ?',
                whereArgs: [record['id']],
              );
            }
          } catch (e) {
            print('Error processing record for $table: $e');
          }
        }

        // Handle deletions from the cloud
        try {
          final cloudDeletedRecords = await connection.query(
              'SELECT * FROM deleted_records WHERE table_name = ?', [table]);

          for (var deletedRecord in cloudDeletedRecords) {
            await db.rawDelete(
                'DELETE FROM $table WHERE id = ?', [deletedRecord['id']]);
          }
        } catch (e) {
          print('Error processing deleted records for $table: $e');
        }
      } catch (e) {
        print('Error syncing table $table: $e');
      }
    }

    // Update last sync time
    await storeLastSyncTime(DateTime.now().toUtc());
    print('Last sync time updated to: ${DateTime.now().toUtc()}');

    await connection.close();
  } catch (e) {
    print('Error connecting to MySQL or syncing data: $e');
  }
}
